@model IEnumerable<SistemadePasteleria.Models.Producto>

@{
    ViewData["Title"] = "Productos";
}

<h1 class="text-center fw-bold mb-4" style="color: #dc3545;">
    <i class="bi bi-cake2-fill me-2"></i>Gestión de Productos
</h1>

<div class="d-flex justify-content-between align-items-center mb-4">
    <a asp-action="Create" class="btn btn-outline-dark px-4 py-2">
        <i class="bi bi-plus-lg"></i> Crear nuevo producto
    </a>

    <!-- Búsqueda: mantiene búsqueda por GET y además activa búsqueda en vivo -->
    <form asp-action="Index" method="get" class="d-flex" role="search">
        <input id="inputBuscar"
               type="text"
               name="buscar"
               class="form-control me-2"
               placeholder="Buscar producto..."
               value="@(ViewData["buscar"] as string)" />
        <button type="submit" class="btn btn-outline-primary">
            <i class="bi bi-search"></i>
        </button>
    </form>
</div>

<table class="table table-hover table-bordered text-center shadow-sm">
    <thead class="table-dark">
        <tr>
            <th>Nombre</th>
            <th>Precio</th>
            <th>Stock</th>
            <th>Imagen</th>
            <th>Categoría</th>
            <th>Acciones</th>
        </tr>
    </thead>

    <!-- El cuerpo de la tabla se actualiza por AJAX -->
    <tbody id="tbodyProductos">
        @Html.Partial("_ProductosRows", Model)
    </tbody>
</table>

@section Scripts {
    <script>
        (function () {
            const input = document.getElementById('inputBuscar');
            const tbody = document.getElementById('tbodyProductos');
            let timer = null;
            let lastTerm = input ? (input.value || '').trim() : '';

            function debounce(fn, delay) {
                return function (...args) {
                    clearTimeout(timer);
                    timer = setTimeout(() => fn.apply(this, args), delay);
                };
            }

            async function buscar(term) {
                try {
                    // Spinner simple mientras carga
                    tbody.innerHTML = `
                        <tr>
                            <td colspan="6" class="text-center">
                                <div class="spinner-border" role="status" aria-label="Cargando resultados"></div>
                            </td>
                        </tr>`;

                    const url = '@Url.Action("Buscar", "Productos")' + '?term=' + encodeURIComponent(term || '');
                    const resp = await fetch(url, { headers: { 'X-Requested-With': 'XMLHttpRequest' } });
                    if (!resp.ok) throw new Error('Error al cargar resultados');
                    const html = await resp.text();
                    tbody.innerHTML = html;
                } catch (e) {
                    console.error(e);
                    tbody.innerHTML = `
                        <tr>
                            <td colspan="6" class="text-center text-danger">Ocurrió un error al buscar.</td>
                        </tr>`;
                }
            }

            const onInput = debounce((ev) => {
                const term = (ev.target.value || '').trim();
                if (term === lastTerm) return; // evita llamadas redundantes
                lastTerm = term;
                buscar(term);
            }, 300); // 300ms es un buen equilibrio

            if (input) {
                input.addEventListener('input', onInput);
            }
        })();
    </script>
}
